{"componentChunkName":"component---src-pages-blog-contentful-blog-post-url-tsx","path":"/blog/javascript-meetup/","result":{"data":{"contentfulBlogPost":{"mainText":{"raw":"{\"nodeType\":\"document\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"On the 27th of October 2022 I attended a \",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://www.meetup.com/frontend-developer-meetup-amsterdam/events/286091455/\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"Frontend Developer Meetup\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\" in Amsterdam. The night consisted of 4 talks and some networking, organised by Passionate People and hosted in the ING office space. These are my takeaways from the night.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-1\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Rendering Strategies – Tim van Bergenhenegouwen\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"The talk started off with a nice history of trends around web rendering, showing the ping-pong of doing more work on the frontend, and then doing more work on the backend. We have a lot of options to choose from because of this, and there is no one-size fits all solution. It is better to choose a strategy based on your needs: \",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"SEO\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Performance\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Speed\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Dynamic content\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Global Users\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"etc\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"There is a lot of information on these strategies as well as many choices you can make within these strategies, such as framework or what combinations you want to use. Here are some I took note of during the talk, many of them often referred to by their acronyms:\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"SSR: Server side rendering\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"SSG: Server side generation\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"SPA: Single page application\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"PWA: Progressive web app\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Offline first\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Things mentioned in the talk that I would like to look into further\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"table\",\"data\":{},\"content\":[{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Svelte\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"I’ve heard about it but never tried it, unlike all the other big web frameworks.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Angular Universal\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Angular’s own SSR implementation.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Web components/Custom elements.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Don’t remember hearing about this before, but looks very cool to do framework-like reactive rendering/component based building using all vanilla JS/HTML DOM and browser functionality.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Lit\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Framework built on top of Web components, seems like most people use this rather than plain web components. After talking to a developer, I found out that ING uses it for the web banking site.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Qwik\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Similar to SSR, but avoids hydration through only downloading the JS that needs to be executed.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Turbopack\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"A Webpack replacement written in rust.\",\"marks\":[],\"data\":{}}]}]}]}]},{\"nodeType\":\"heading-1\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Is this the end of E2E – Tobias Kuppens Groot\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Tobias covered a brief summary of what E2E testing is, why we use it, and why it might not be the most valuable use of a developer's resources. We use E2E testing to validate communication; communication between frontend and backend services, between separate backend services, external integrations, and communication between user and UI, all at once. \",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Because of this, tests need to be run monolithically. Everything is deployed and tested together. If any one of these pieces of the monolith change, then the results of the test becomes stale and the next tests will (should) fail. This is flaky, makes tests hard to refactor and slow to fix and debug. On top of this, it relies on the relevant test data to be present in the environment you are testing.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Their suggestion is to add another layer to the bottom of \",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://martinfowler.com/articles/practical-test-pyramid.html#TheTestPyramid\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"Martin Fowler's Testing Pyramid\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\": the type-safety system. You use it to confirm that you have valid code and provide confidence that the code will work. It is extremely quick because you get feedback as you're writing the code, whether as an IDE integration or in compile errors when building the code.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"In order to use this new pyramid layer to validate communication between the frontend and backend, you can use type generators for API specs. This tends to work better with an API-first design, as you can be sure that both frontend and backend are holding up their end of the contract. With these API generations, you can also rely on a live service layer, allowing you to concentrate on the UI without worrying about the details of the network requests. Another advantage of this is that it can be mocked out in tests using something like \",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://mswjs.io/\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"Mock Service Worker\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\".\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Things mentioned in the talk that I would like to look into further\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"table\",\"data\":{},\"content\":[{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Vite\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"No bundle based frontend tool, using native ESM.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://micro-frontends.org/\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"Micro frontends\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"A new technique similar to microservices for backend, but separating responsibility and creating domains for the front end (heavily favouring web components as it makes a lot of the ideals easier to implement).\",\"marks\":[],\"data\":{}}]}]}]}]},{\"nodeType\":\"heading-1\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Event-driven Dependency Injection - Matius Fernandez Martinez\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"This talk was about creating a solution for dependency injection (resolution) when working with web components, since with most modern frameworks you get it out of the box. Dependency injection helps with inversion of control, where a framework will call your custom code and provide services rather than you calling the framework methods to get services. \",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"The solution is smart in its simplicity. Since you’re using DOM elements, you can use the event system to bubble up events to ‘provider’ custom elements further up in the tree. It also all works synchronously, so dependencies are resolved without waiting. You can see the full repo with this implemented here: \",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://github.com/thematho/lit-elements-dependency-injection-demo\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"https://github.com/thematho/lit-elements-dependency-injection-demo\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\". It utilises mixins to avoid boilerplate with setting up the event listeners and dispatchers.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-1\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Effortless full-stack type-safety with pure TypeScript – Jasper Haggenburg\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"This talk was by the creators of a new frontend/backend framework called \",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://phero.dev/docs/introduction\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"Phero\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\". Similar to the 2nd talk, this framework utilises type generation from backend APIs to provide better confidence and developer experience when integrating frontend with backend. The twist here is that you don't need to spec out the backend services, instead Phero utilises the typescript compiler to generate the interfaces from the types used in your backend functions. On top of this, it also generates errors for custom errors you use in your backend functions. I hadn't heard of RPC (remote procedure calling) until this talk, but it makes a lot of sense when writing web applications. \",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Lots of questions from the audience revealed there is much still in planning, as the framework is quite young still. Things like API versioning when making breaking changes between interfaces, automatic documentation generation and custom HTTP status codes are all things that they are looking to work on moving forward.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Things mentioned in the talk that I would like to look into further\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"table\",\"data\":{},\"content\":[{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"TRPC\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Similar concept to Phero, much more mature, and you don't quite get the same functionality out of the box.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"table-row\",\"data\":{},\"content\":[{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Zod\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"table-cell\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\" Typescript schema validation that you use with TRPC to get the API input/output validation that is also a feature of Phero.\",\"marks\":[],\"data\":{}}]}]}]}]},{\"nodeType\":\"heading-1\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Last thing\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"This was the first meetup/tech talk I had been to in a while, and it was fun to get back into the swing of things. I got to chat to some very friendly, like-minded developers, and I came away with a lot of new things to try. Not to mention, it inspired me to start this blog!\",\"marks\":[],\"data\":{}}]}]}"},"title":"Javascript Meetup"}},"pageContext":{"id":"e5724572-0c8e-54d3-aa5a-d7a705ee2cb2","url":"javascript-meetup","__params":{"url":"javascript-meetup"}}},"staticQueryHashes":[]}